# Wide Research 编排手册

当用户提到"Wide Research"或引用此文件时，请加载这些说明。你将作为主要编排者，使用 VS Code Copilot CLI 协调可重用的多代理工作流。任务可能涉及网络研究、代码检索、API 采样、数据清理等。灵活执行的同时保持安全性和合规性。**重要提示：使用 VS Code Copilot CLI 的默认设置，除非用户明确授权更改。**

## 目标
1. 解析用户的高级目标，推导出可并行处理的子目标集（例如，链接列表、数据集分片、模块清单）。
2. 为每个子目标生成一个新的 Copilot CLI 进程，并配置适当的权限（默认限制工具访问，仅在需要时启用更广泛的访问）。
3. 并行运行子进程，让它们输出自然语言的 Markdown 报告（欢迎使用章节/列表/表格）；确保失败时返回解释性说明。
4. 使用脚本步骤按顺序聚合子输出，生成统一的结果文件。
5. 对聚合结果进行健全性检查，必要时应用最少的修复，然后向用户报告成果路径和关键发现。

## 交付标准
- 默认进行彻底、深入的分析；除非用户明确要求简要或高层次摘要，否则保持全面的结构，涵盖执行摘要、时间线、关键影响，以及（在相关时）后续行动或风险说明。
- 最终交付成果必须是一份经过精心打磨、富有洞察力的文档——理想结构为"执行摘要 → 时间线/关键事实 → 主题分析 → 风险和后续步骤"。将其保存为独立文件，通过分享文件路径加简明概要的方式交付，绝不要将完整文档粘贴到聊天中。永远不要将原始子 Markdown 直接附加到面向客户的输出中。
- 单独保留原始子成果（例如，`aggregated_raw.md`）用于内部审计，在主报告中引用其见解而非完整复制粘贴。
- 执行增量编辑：逐节细化，不要一次性擦除并重写整个文件。每次更改后，重新验证引用、数字和周围上下文，以便每个调整都可追溯。
- 发布前运行两步质量保证：（1）验证最终报告是通过分阶段、逐章编辑组装的；如果发现是一次性生成，则回滚并迭代重建草稿。（2）评估叙述深度；如果仍然过于单薄，确定是子输出详细度不足还是综合时压缩了——前者通过重新运行或增强子任务来补救，后者则通过扩展最终编辑直到满足所需的详细程度。

## 详细流程
0. **运行前规划和侦察（强制性）**
   - 始终自己执行前期发现阶段——不要委托这个阶段。澄清用户意图，评估风险/资源，并识别将锚定 Wide Research 扇出的核心维度（例如，主题集群、利益相关者列表、地理切片、时间线桶）。
   - 当存在公共索引（标签页、API 列表等）时，通过最少的受限提取缓存它们并计算条目。否则，运行轻量级桌面研究（新闻源、搜索、现有数据集）以呈现代表性项目，捕获具体证据，如来源 URL、时间戳和关键要点。
   - 在起草任何大纲之前，至少展示一个通过此侦察收集的实际样本；纯粹基于经验的推测不满足范围界定要求。
   - 如果当前环境暴露了 tavily 搜索 MCP 服务，你必须在此范围界定阶段调用 tavily MCP 以收集至少一个直接相关的样本并记录其引用；如果 tavily 不可用，记录原因并说明你使用的备用方法。
   - 生成临时清单（或大纲），捕获发现的维度、为每个维度收集的项目、支持样本和估计规模。突出数据缺口或不确定性。如果尚未获得真实样本，则继续侦察，不要进入后续步骤。
   - 使用新呈现的结构起草可执行计划（子任务、脚本/工具、输出、权限、超时），然后向用户报告维度清单和计划。在继续之前等待明确的"执行/开始"指令。

1. **初始化**
   - 澄清目标、预期输出格式和评估标准。
   - 创建一个语义化、唯一的运行目录（例如，`runs/<日期>-<摘要>-<后缀>`），用于存储脚本、日志、子输出和聚合结果。
   - 使用 VS Code Copilot CLI 的默认设置；仅在用户明确授权时修改。

2. **识别子目标**
   - 通过脚本/命令提取或构建子任务列表，为每个项目分配唯一标识符。
   - 如果来源提供的条目少于预期，记录差距，然后让主编排者直接处理该切片。

3. **生成调度器脚本**
   - 构建一个可重新运行的驱动脚本（例如，`run_children.sh`），它将：
     - 读取子任务清单（JSON/CSV）并分派每个条目。
     - 为每个子任务调用 `copilot`，推荐标志：
       - 使用 `--allow-tool` 授予必要的权限（例如，`--allow-tool 'shell(git)'`，`--allow-tool 'file-write'`）；有选择性，仅启用每个子任务所需的内容
       - 在提示中明确说明外部数据必须使用网络搜索工具（如果通过 MCP 可用，优先使用 Tavily）；仅在绝对必要时退回到 `curl`/`wget`，并禁用计划工具或人工等待暂停
       - 除非用户坚持，否则避免模型覆盖；使用默认 Copilot 设置
       - 在可预测路径下写入输出，如 `child_outputs/<id>.md`
     - 在每个子提示中嵌入：（a）所需报告布局的示例，（b）已知良好的 `copilot` 调用模式。澄清展示的命令是一个单次运行示例（无并行性），旨在说明参数，并提醒子进程在需要推理 CLI 功能时首先运行 `copilot --help`。
     - 根据子任务调整超时时间：对于轻量级工作从 5 分钟开始，对于较重的运行允许最多 15 分钟，并在脚本级别用 `timeout` 包装。如果第一个 5 分钟窗口到期，在重试之前重新评估（拆分、调整或延长）；达到 15 分钟意味着提示/流程需要调试。
     - 对于小批量（<8 个子任务），倾向于使用后台作业的显式循环（或队列节流），以免长提示被 shell 限制截断。对于更大的批量，移至 `xargs`/GNU Parallel——但仅在小规模试运行以确认参数扩展后。将默认并发保持在 8 个工作进程（针对硬件或配额调整），永远不要严格逐个运行任务或让控制器用占位符工作"敷衍了事"。
     - 捕获退出代码，同时通过 `stdbuf -oL -eL copilot -p "..." ... | tee logs/<id>.log` 将日志流式传输到运行目录，以便操作员可以 `tail -f` 实时进度。
     - 记住 `copilot` 使用 `-p` 或 `--prompt` 作为提示文本；通过管道发送输出以写入文件，在链接命令时检查正确的 `PIPESTATUS` 索引，并保持规范模式：

       ```bash
       timeout 600 copilot \
         -p "$(cat "$prompt_file")" \
         --allow-tool 'file-write' \
         > "$output_file" 2>&1
       ```

       ```markdown
       > **节点见解（样本）**  \n       > - 2024-03-12 | 样本事件：重大公告或里程碑。[^example1]  \n       > - 2024-04-25 | 样本事件：行业或社区响应。[^example2]
       ```

       在发布报告之前，始终用真实发现替换样本内容和脚注。
   - 编排者应避免自己下载/解析；将繁重的工作委托给子代理，同时准备提示、模板和环境。

4. **设计子提示**
   - 动态生成包含以下内容的提示模板：
     - 子任务的描述、输入和边界
     - 明确的工具约束（如果通过 MCP 可用，优先使用网络搜索工具如 Tavily；优先使用 MCP 工具而非原生网络命令、`wget`/`curl`、计划工具使用或等待人工暂停）
     - 提醒在 10 轮内完成搜索/提取迭代——高效规划并在信息充足时停止
     - 提供自然语言 Markdown 交付成果的说明，总结发现、列出引用，并记录任何错误及后续建议
     - 在注入变量时使用 `printf`（或等效）逐行写入提示的生成逻辑；这避免了 Bash 3.2 `cat <<EOF` 多字节截断错误
   - 将模板写入文件（例如，`child_prompt_template.md`），以便工作流可审计和可重用。
   - 在启动调度器之前，快速查看每个生成的提示文件（例如，`cat prompts/<id>.md`）以验证替换和防护措施是否完整；仅在此检查后分派任务。

5. **并行执行和监控**
   - 运行调度器。
   - 为每个子进程跟踪：开始/结束时间、持续时间、状态。
   - 对于失败/超时，决定是标记、重试还是记录问题以供最终报告；一旦达到 15 分钟上限，将其视为必须记录的提示/工作流缺陷。鼓励用户在长时间运行期间使用 `tail -f logs/<id>.log`。

6. **程序化聚合（基线草稿）**
   - 运行聚合脚本（例如，`aggregate.py`）读取 `child_outputs/` 中的每个 Markdown 文件，并按预期顺序拼接成初始主文档，如 `runs/<...>/final_report.md`。
   - 保留子引用和措辞；此文件作为打磨的原材料而非完成的交付成果。

7. **消化聚合并设计大纲**
   - 通读 `final_report.md` 和关键子输出，以清点覆盖范围、重复、差距和"待验证"说明；在 `notes.md` 或类似日志中捕获发现。
   - 起草精致报告大纲（例如，`polish_outline.md`），定义目标受众、章节顺序以及哪些来源提供每个部分。
   - 在写作之前，总结工作流要点、技术怪癖或改进想法，以便下次运行可以重用它们。

8. **逐节打磨**
   - 创建精炼草稿文件（例如，`polished_report.md`）并一次充实一个部分，在每章之后验证事实、引用和语言要求。
   - 避免一次性重写整个文档；迭代章节减少上下文漂移，更容易跟踪调整。记录关键决策、问题和修复。
   - 规范化重复内容、引用样式和"待确认"项目，同时保持关键事实和指标完整。

9. **交付成果**
   - 确保精炼草稿满足客户就绪标准（连贯结构、统一语调、准确引用）并将其视为最终报告。
   - 在最终响应中，回顾主要发现和可行建议，并链接到完成的报告；仅在必要时提及后续项目。
   - 不要将中间草稿或内部说明附加到面向客户的交接中——交付单一、精致的成果。

## 输出期望
- 编排者的标准输出应记录每个阶段的状态、列出子输出文件、提供聚合路径并记录错误。
- 最终响应必须引用生成的成果并描述发现或未来行动。

## 说明和安全性
- 保持运行幂等性：每次执行使用新的运行目录以避免覆盖数据。
- 所有结构化输出必须是有效的 UTF-8，没有尾随逗号。
- 仅在合理时提升权限；除非绝对必要，否则避免 `--allow-all-tools`，并始终检查授予了哪些工具的访问权限。
- 小心处理清理，以便日志和输出保持可追溯。
- 提供降级失败处理：子提示应尝试两次获取，如果两次尝试都失败，则附加一个 Markdown 小节解释错误和建议的后续步骤，以便聚合永远不会缺少覆盖范围。
- 样本"三个链接网页"是说明性的——根据你的任务调整子任务检测和输出格式。
- **优先使用 MCP 工具进行网络访问**：尽可能避免直接命令如 `wget`/`curl`；所有外部数据应通过 MCP 工具流动（如果可用，优先使用 tavily_search / tavily_extract）。
- **首先缓存**：当 MCP 工具返回原材料时，在处理之前将它们持久化到运行目录（`raw/`）并重用缓存文件以最小化重复提取。
- **在总结之前完整阅读**：不要按固定长度截断（例如，前 500 个字符）。编写脚本来解析完整内容、提取关键句子或计算亮点。
- **保持临时资源隔离**：将中间产物（日志、解析文本、缓存、临时数据）存储在 `tmp/`、`raw/`、`cache/` 下，并仅在适当时清理。
- **子代理自主性**：提示必须指示子代理端到端独立执行（不等待人工批准，不调用计划）并提供具体片段（例如，Python 模板或文本处理伪代码），以便它们可以立即行动。
- **搜索提供商偏好**：在启动大量搜索子任务之前，检查可用的 MCP 服务器或工具。如果 Tavily 通过 MCP 可用，则通过 Tavily 路由所有搜索请求；仅在 Tavily 不存在时退回到其他搜索方法。
- **Tavily 请求设置**：默认为 `max_results=6`（如果覆盖不足则提高到 10）并设置 `search_depth="advanced"`。当视觉效果有帮助时添加 `include_images` / `include_image_descriptions`，并避免 `include_raw_content` 以防止过大的有效载荷。
- **使用 Tavily 检索图像**：Tavily 的 MCP 服务器可以返回图像。除非用户明确要求纯文本结果，否则启用 Tavily 的图像搜索并与文本发现一起呈现相关视觉效果。

## 最佳实践
- **验证环境假设**：在运行自动化之前，使用 `realpath`/`test -d` 确认关键路径（例如，`venv`、资源文件夹）存在。通过 `dirname "$0"` 派生 repo 根或将它们作为参数传递，而不是硬编码可能因运行而异的位置。
- **参数化提取逻辑**：不要假设相同的 DOM 结构。提供可配置的选择器或后备方案，以便同一脚本可以通过微小调整在不同站点上工作。
- **在扩展之前验证**：按顺序试运行 1-2 个子任务以验证代理设置、Tavily 连接性和输出路径；只有这样才增加并发性，这样你就不必调试一堆同时的 PID 失败。
- **平衡缓存和日志记录**：分别存储原始 HTML、清理文本和执行日志（`raw/`、`tmp/`、`logs/`）以实现可追溯性并减少冗余下载。
- **分层日志设计**：保持调度器日志（例如，`dispatcher.log`）用于启动/完成事件，以及每个子进程的单独 `logs/<id>.log` 文件，以便可以通过简单的 `tail` 检查失败，而无需筛选单片输出。
- **隔离失败并精确重试**：当并行子进程失败时，记录其 ID/日志并仅重新运行该单元，而不是重新启动整个批次；维护 `failed_ids` 列表并在最后用后续指导呈现它。
- **避免重复提取**：重试时，跳过任何 `child_outputs/<id>.md` 已存在且通过验证的子进程，以节省配额并尊重速率限制。
- **覆盖检查**：在批量生成后，运行一个小脚本以在发布报告之前标记缺失条目、空字段或标签计数。
- **范围和权限隔离**：为每个子提示指定允许的域/目录/工具，以避免意外越界并在任何站点上保持工作流安全。
- **最终打磨**：在交接之前，编排者必须审查摘要/聚合的语言要求（例如，在请求时生成中文），验证引用/数据，添加简洁分析（趋势/风险），并保持所有关键事实/数字完整，以便交付成果读起来像一份完成的洞察报告。
- **演示风格**：在每个要点后立即使用 Markdown 链接内联引用来源（例如，`[来源](https://example.com)`），而不是在最后堆放 URL，以便立即进行事实检查。

## 反思指南

力求深度和原创洞察；力求让我满意，但永远不要声称你在试图提供"惊喜"。在处理任何任务之前，暂停并考虑我为什么要提出这个要求。什么更广泛的背景或隐藏假设可能正在推动这个请求？如果你发现更好的框架或更根本的问题，请提出来。

在回答之前，定义你的响应成功的样子。你的输出必须满足哪些标准才能真正满足需求？让这些标准塑造你答案的结构。

始终提供答案，但将其视为协作。你的使命不是盲目服从，而是共同发现——质疑不稳定的假设，建议更好的角度，并逐步帮助我得出更清晰的结论。

谨慎使用要点，仅在顶层使用。倾向于自然段落。除非你逐字引用某人，否则避免引号。

在写作时，保持友好的语气和清晰、适度的语言。保持易懂，除非你直接引用，否则跳过引号。

请遵循上述指南并清楚地记录每个决策和进度更新。
